//! ブロックチェーンデータ構造定義
//!
//! このモジュールはブロックチェーンアプリケーション全体で使用される
//! コアデータ構造を定義します。ブロック、トランザクション、
//! ネットワークピアの構造体を含み、ブロックチェーンのデータモデルの
//! 基盤を形成します。
//!
//! データ構造の設計原則：
//! - 不変性: ブロックは一度作成されたら変更されない
//! - 連鎖性: 各ブロックは前のブロックを参照
//! - 検証可能性: すべてのデータはハッシュで検証可能
//! - 拡張性: 新しいトランザクションタイプを追加可能

const std = @import("std");

//------------------------------------------------------------------------------
// コアブロックチェーンデータ構造
//------------------------------------------------------------------------------

/// トランザクション情報
/// ブロックチェーン上の価値移転やスマートコントラクトの操作を表現します
/// 
/// トランザクションの役割：
/// - 状態変更の単位（送金、コントラクト実行など）
/// - 署名により送信者の意図を証明（本実装では省略）
/// - ガス料金により計算資源の使用を制限
/// 
/// なぜこれらのフィールドが必要なのか：
/// - sender/receiver: 誰から誰への操作かを明確にする
/// - amount: 送金額（0の場合もある、例：単なる関数呼び出し）
/// - tx_type: 処理方法を決定するため
/// - evm_data: コントラクトのコードや関数の引数を格納
/// - gas_limit/price: DoS攻撃を防ぎ、マイナーに報酬を提供
pub const Transaction = struct {
    /// 送信者のアドレス（本来は公開鍵から導出）
    sender: []const u8,
    
    /// 受信者のアドレス（EOAまたはコントラクト）
    receiver: []const u8,
    
    /// 送金額（wei単位）
    amount: u64,
    
    /// トランザクションのタイプ
    /// 0: 通常の送金（ETHの移動のみ）
    /// 1: スマートコントラクトのデプロイ（新規作成）
    /// 2: スマートコントラクトの呼び出し（既存の実行）
    tx_type: u8 = 0,
    
    /// EVMバイトコード（デプロイ時）または呼び出しデータ（実行時）
    /// - デプロイ時: コンストラクタコード + ランタイムコード
    /// - 呼び出し時: 関数セレクタ(4バイト) + 引数
    evm_data: ?[]const u8 = null,
    
    /// ガス上限（実行可能な最大計算量）
    /// デフォルト: 1,000,000（単純な送金は21,000で十分）
    gas_limit: usize = 1000000,
    
    /// ガス価格（1ガスあたりの料金、wei単位）
    /// デフォルト: 20 Gwei = 20,000,000,000 wei
    gas_price: u64 = 20000000000,
    
    /// トランザクションの一意識別子（ハッシュ値）
    id: [32]u8 = [_]u8{0} ** 32,
};

/// ブロックチェーン内の単一ブロックを表すブロック構造体
///
/// ブロックは複数のトランザクションを含み、チェーンの一部を形成します。
/// 各ブロックは前のブロックへの暗号的リンクを含み、
/// チェーン構造を作成します。
///
/// ブロックの重要な性質：
/// 1. 不変性: 一度作成されたブロックは変更できない
/// 2. 連鎖性: prev_hashにより前のブロックと暗号的にリンク
/// 3. 検証可能性: ハッシュにより内容の正当性を確認可能
/// 4. タイムスタンプ: いつ作成されたかの証拠
///
/// なぜこの構造なのか：
/// - index: ブロックの順序を明確にする
/// - prev_hash: チェーンの改ざんを検出可能にする
/// - nonce + hash: プルーフオブワークの証明
/// - transactions: 実際の価値移転の記録
/// - contracts: スマートコントラクトの状態同期
pub const Block = struct {
    /// ブロックチェーン内の連続位置（ジェネシスブロックは0から開始）
    index: u32,

    /// Unixタイムスタンプ（エポックからの経過秒数）としての作成時刻
    timestamp: u64,

    /// 前のブロックのハッシュ、チェーン構造を作成
    /// ジェネシスブロックの場合はゼロで埋められる
    prev_hash: [32]u8,

    /// このブロックに含まれるトランザクションのリスト
    transactions: std.ArrayList(Transaction),

    /// プルーフオブワーク要件を満たすためにマイニング中に変更される値
    nonce: u64,

    /// ブロックに格納される追加データ（任意の情報）
    data: []const u8,

    /// このブロックの内容の暗号ハッシュ（SHA-256）
    /// 他のすべてのフィールドに基づいて計算され、難易度要件を満たす必要がある
    hash: [32]u8,

    /// コントラクトアドレスとバイトコードのマップ（null可）
    /// 各ブロックには、そのブロックで新たにデプロイされたコントラクトのコードが含まれる
    /// コントラクトストレージの同期に使用される
    contracts: ?std.StringHashMap([]const u8) = null,
};

//------------------------------------------------------------------------------
// ネットワーク関連構造体
//------------------------------------------------------------------------------

/// 別のノードへの接続を表すネットワークピア構造体
///
/// ピアツーピアネットワーク内の接続されたピアを表します。
/// 各ピアは通信用のアドレスとネットワークストリームを持ちます。
///
/// P2Pネットワークでのピアの役割：
/// - ブロックの伝播: 新しいブロックを他のノードに送信
/// - チェーンの同期: より長いチェーンを持つピアから更新
/// - トランザクションの共有: 未確認トランザクションの拡散
///
/// なぜこの構造なのか：
/// - address: ピアを一意に識別し、再接続を可能にする
/// - stream: 双方向通信のためのTCPコネクション
pub const Peer = struct {
    /// ピアのネットワークアドレス（IP:ポート）
    /// 例: 192.168.1.1:8000
    address: std.net.Address,

    /// ピアとの通信用のアクティブな接続ストリーム
    /// - 読み取り: 新しいブロックやメッセージの受信
    /// - 書き込み: ブロックやトランザクションの送信
    stream: std.net.Stream,
};
